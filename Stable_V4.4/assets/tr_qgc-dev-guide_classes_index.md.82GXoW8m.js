import{_ as e,o as a,c as i,R as t}from"./chunks/framework.jcLJieDC.js";const p=JSON.parse('{"title":"Class Hierarchy (high level)","description":"","frontmatter":{},"headers":[],"relativePath":"tr/qgc-dev-guide/classes/index.md","filePath":"tr/qgc-dev-guide/classes/index.md"}'),n={name:"tr/qgc-dev-guide/classes/index.md"},r=t('<h1 id="class-hierarchy-high-level" tabindex="-1">Class Hierarchy (high level) <a class="header-anchor" href="#class-hierarchy-high-level" aria-label="Permalink to &quot;Class Hierarchy (high level)&quot;">​</a></h1><h2 id="linkmanager-linkinterface" tabindex="-1">LinkManager, LinkInterface <a class="header-anchor" href="#linkmanager-linkinterface" aria-label="Permalink to &quot;LinkManager, LinkInterface&quot;">​</a></h2><p>A &quot;Link&quot; in QGC is a specific type of communication pipe with the vehicle such as a serial port or UDP over WiFi. The base class for all links is LinkInterface. Each link runs on it&#39;s own thread and sends bytes to MAVLinkProtocol.</p><p>The <code>LinkManager</code> object keeps track of all open links in the system. <code>LinkManager</code> also manages automatic connections through serial and UDP links.</p><h2 id="mavlinkprotocol" tabindex="-1">MAVLinkProtocol <a class="header-anchor" href="#mavlinkprotocol" aria-label="Permalink to &quot;MAVLinkProtocol&quot;">​</a></h2><p>There is a single <code>MAVLinkProtocol</code> object in the system. It&#39;s job is to take incoming bytes from a link and translate them into MAVLink messages. MAVLink HEARTBEAT messages are routed to <code>MultiVehicleManager</code>. All MAVLink messages are routed to Vehicle&#39;s which are associated with the link.</p><h2 id="multivehiclemanager" tabindex="-1">MultiVehicleManager <a class="header-anchor" href="#multivehiclemanager" aria-label="Permalink to &quot;MultiVehicleManager&quot;">​</a></h2><p>There is a single <code>MultiVehicleManager</code> object within the system. When it receives a HEARTBEAT on a link which has not been previously seen it creates a Vehicle object. <code>MultiVehicleManager</code> also keeps tracks of all Vehicles in the system and handles switching from one active vehicle to another and correctly handling a vehicle being removed.</p><h2 id="vehicle" tabindex="-1">Vehicle <a class="header-anchor" href="#vehicle" aria-label="Permalink to &quot;Vehicle&quot;">​</a></h2><p>The Vehicle object is the main interface through which the QGC code communicates with the physical vehicle.</p><p>Note: There is also a UAS object associated with each Vehicle which is a deprecated class and is slowly being phased out with all functionality moving to the Vehicle class. No new code should be added here.</p><h2 id="firmwareplugin-firmwarepluginmanager" tabindex="-1">FirmwarePlugin, FirmwarePluginManager <a class="header-anchor" href="#firmwareplugin-firmwarepluginmanager" aria-label="Permalink to &quot;FirmwarePlugin, FirmwarePluginManager&quot;">​</a></h2><p>The FirmwarePlugin class is the base class for firmware plugins. A firmware plugin contains the firmware specific code, such that the Vehicle object is clean with respect to it supporting a single standard interface to the UI.</p><p>FirmwarePluginManager is a factory class which creates a FirmwarePlugin instance based on the MAV_AUTOPILOT/MAV_TYPE combination for the Vehicle.</p>',14),s=[r];function c(l,o,h,d,m,g){return a(),i("div",null,s)}const k=e(n,[["render",c]]);export{p as __pageData,k as default};
