import{_ as a,c as i,o as r,ag as n}from"./chunks/framework.Dne1pdn_.js";const u=JSON.parse('{"title":"类层次结构（上层）","description":"","frontmatter":{},"headers":[],"relativePath":"zh/qgc-dev-guide/classes/index.md","filePath":"zh/qgc-dev-guide/classes/index.md"}'),l={name:"zh/qgc-dev-guide/classes/index.md"};function o(t,e,c,d,h,m){return r(),i("div",null,e[0]||(e[0]=[n('<h1 id="类层次结构-上层" tabindex="-1">类层次结构（上层） <a class="header-anchor" href="#类层次结构-上层" aria-label="Permalink to &quot;类层次结构（上层）&quot;">​</a></h1><h2 id="linkmanager-linkinterface-连接管理器类和链接接口类" tabindex="-1">（LinkManager, LinkInterface）连接管理器类和链接接口类 <a class="header-anchor" href="#linkmanager-linkinterface-连接管理器类和链接接口类" aria-label="Permalink to &quot;（LinkManager, LinkInterface）连接管理器类和链接接口类&quot;">​</a></h2><p>QGC中的“链接”是一种特定类型的通信管道，例如串行端口或WiFi上的UDP。 LinkInterface为所有链接的基类。 每个链接都在它自己的线程上运行，并且发送字节（bytes）到MAVLink协议中。</p><p><code>LinkManager</code> 对象将跟踪系统中所有打开的链接。 <code>LinkManager</code>也通过串行链接和 UDP链接管理自动连接。</p><h2 id="mavlinkprotocol-mavlink协议类" tabindex="-1">（MAVLinkProtocol）MAVLink协议类 <a class="header-anchor" href="#mavlinkprotocol-mavlink协议类" aria-label="Permalink to &quot;（MAVLinkProtocol）MAVLink协议类&quot;">​</a></h2><p>系统中有一个单一的 <code>MAVLinkProtocol</code> 对象。 它的工作是接收从链路传入的字节，并将其转换为 MAVLink 信息。 MAVLink HEARTBEAT 消息已路由到 <code>MultivehicleManager</code> 。 （Vehicle）载具类</p><h2 id="multivehiclemanager-多载具管理类" tabindex="-1">（MultiVehicleManager）多载具管理类 <a class="header-anchor" href="#multivehiclemanager-多载具管理类" aria-label="Permalink to &quot;（MultiVehicleManager）多载具管理类&quot;">​</a></h2><p>系统内有一个单独的 <code>MultiVoilleManager</code> 对象。 当它在以前没有连接过的链接上收到 HEARTTBEAT（心跳包） 时，它会产生一个载具对象（object）。 <code>MultiVehicleManager</code> 还会跟踪系统中的所有载具，并处理从一个活动载具到另一个活动载具的切换，并正确处理被移除的车辆。</p><h2 id="vehicle-载具类" tabindex="-1">(Vehicle)载具类 <a class="header-anchor" href="#vehicle-载具类" aria-label="Permalink to &quot;(Vehicle)载具类&quot;">​</a></h2><p>Vehicle类所生成的对象是QGC代码与物理载具通信的主要接口。</p><p>注意：还有一个与每个Vehicle相关联的UAS对象，这是一个已弃用的类，并且正逐渐被逐步淘汰，所有功能都将转移到Vehicle类。 在此处不应添加新的代码。</p><h2 id="firmwareplugin-firmwarepluginmanager-固件插件类和固件插件管理器类" tabindex="-1">（FirmwarePlugin，FirmwarePluginManager）固件插件类和固件插件管理器类 <a class="header-anchor" href="#firmwareplugin-firmwarepluginmanager-固件插件类和固件插件管理器类" aria-label="Permalink to &quot;（FirmwarePlugin，FirmwarePluginManager）固件插件类和固件插件管理器类&quot;">​</a></h2><p>FirmwarePlugin 类为固件插件的基类。 FirmwarePlugin类为固件插件的基类。 固件插件包含固件特定代码，因此Vehicle对象相对于它是识别的，支持UI的单个标准接口。</p><p>FirmwarePluginManager是一个工厂类，它根据Vehicle类的成员MAV_AUTOPILOT / MAV_TYPE组合创建FirmwarePlugin类的实例。</p>',14)]))}const g=a(l,[["render",o]]);export{u as __pageData,g as default};
