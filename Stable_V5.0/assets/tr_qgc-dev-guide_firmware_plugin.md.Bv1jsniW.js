import{_ as i,c as t,o as a,ag as r}from"./chunks/framework.DBOa9Nxc.js";const d=JSON.parse('{"title":"Plugin Architecture","description":"","frontmatter":{},"headers":[],"relativePath":"tr/qgc-dev-guide/firmware_plugin.md","filePath":"tr/qgc-dev-guide/firmware_plugin.md"}'),o={name:"tr/qgc-dev-guide/firmware_plugin.md"};function n(s,e,c,h,l,u){return a(),t("div",null,e[0]||(e[0]=[r('<h1 id="plugin-architecture" tabindex="-1">Plugin Architecture <a class="header-anchor" href="#plugin-architecture" aria-label="Permalink to &quot;Plugin Architecture&quot;">​</a></h1><p>Although the MAVLink spec defines a standard communication protocol to communicate with a vehicle. There are many aspects of that spec that are up for interpretation by the firmware developers. Because of this there are many cases where communication with a vehicle running one firmware is be slightly different than communication with a vehicle running a different firmware in order to accomplish the same task. Also each firmware may implement a different subset of the MAVLink command set.</p><p>Another major issue is that the MAVLink spec does not cover vehicle configuration or a common parameter set. Due to this all code which relates to vehicle setup ends up being firmware specific. Also any code which must refer to a specific parameter is also firmware specific.</p><p>Given all of these differences between firmware implementations it can be quite tricky to create a single ground station application that can support each without having the codebase degrade into a massive pile of if/then/else statements peppered everywhere based on the firmware the vehicle is using.</p><p>QGC uses a plugin architecture to isolate the firmware specific code from the code which is generic to all firmwares. There are two main plugins which accomplish this <code>FirmwarePlugin</code> and <code>AutoPilotPlugin</code>.</p><p>This plugin architecture is also used by custom builds to allow ever further customization beyond when standard QGC can provide.</p><h2 id="firmwareplugin" tabindex="-1">FirmwarePlugin <a class="header-anchor" href="#firmwareplugin" aria-label="Permalink to &quot;FirmwarePlugin&quot;">​</a></h2><p>This is used to create a standard interface to parts of Mavlink which are generally not standardized.</p><h2 id="autopilotplugin" tabindex="-1">AutoPilotPlugin <a class="header-anchor" href="#autopilotplugin" aria-label="Permalink to &quot;AutoPilotPlugin&quot;">​</a></h2><p>This is used to provide the user interface for Vehicle Setup.</p><h2 id="qgccoreplugin" tabindex="-1">QGCCorePlugin <a class="header-anchor" href="#qgccoreplugin" aria-label="Permalink to &quot;QGCCorePlugin&quot;">​</a></h2><p>This is used to expose features of the QGC application itself which are not related to a Vehicle through a standard interface. This is then used by custom builds to adjust the QGC feature set to their needs.</p>',12)]))}const m=i(o,[["render",n]]);export{d as __pageData,m as default};
